<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="15.0">

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup>
    <MsixTaskAssemblyLocation Condition="'$(MsixTaskAssemblyLocation)'==''">$(MSBuildThisFileDirectory)..\tools\</MsixTaskAssemblyLocation>
    <MsixTaskAssembly>$(MsixTaskAssemblyLocation)Microsoft.Build.Msix.dll</MsixTaskAssembly>
    <MsixTaskAssemblyNamespace>Microsoft.Build.Msix</MsixTaskAssemblyNamespace>
  </PropertyGroup>

  <!-- WindowsTools -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).WindowsTools.ReunionGetSdkFileFullPath" />

  <!-- Recipe -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Recipe.ReunionGenerateAppxPackageRecipe" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Recipe.ReunionExpandPayloadDirectories" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Recipe.ReunionRemovePayloadDuplicates" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Recipe.ReunionGenerateProjectArchitecturesFile" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Recipe.ReunionGetPackageArchitecture" />

  <!-- AppxManifest -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).AppxManifest.ReunionRemoveDuplicateSDKReferences" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).AppxManifest.ReunionGenerateAppxManifest" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).AppxManifest.ReunionGetFrameworkSdkPackages" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).AppxManifest.ReunionValidateAppxManifestItems" />

  <!-- MakeAppx -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).MakeAppx.ReunionGetAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).MakeAppx.ReunionMakeAppxPack" />

  <!-- Symbols -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Symbols.ReunionGenerateAppxSymbolPackage" />

  <!-- Signing -->
  <UsingTask AssemblyFile="$(MsixTaskAssembly)" TaskName="$(MsixTaskAssemblyNamespace).Crypto.ReunionSignAppxPackage" />

  <PropertyGroup>
    <SDKIdentifier Condition="'$(SDKIdentifier)' == ''">UAP</SDKIdentifier>
    <SDKVersion Condition="'$(SDKVersion)' == ''">10.0</SDKVersion>
    <_QualifiersPath>$(IntermediateOutputPath)qualifiers.txt</_QualifiersPath>
    <_ProjectArchitecturesFilePath>$(IntermediateOutputPath)ProjectArchitectures.txt</_ProjectArchitecturesFilePath>
    <AppxPackageDirName Condition="'$(AppxPackageDirName)' == ''">AppPackages</AppxPackageDirName>
    <AppxPackageUploadDirName Condition="'$(AppxPackageUploadDirName)' == ''">Upload</AppxPackageUploadDirName>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(OutDir)$(AppxPackageDirName)\</AppxPackageDir>
    <AppxPackageDir Condition="!HasTrailingSlash('$(AppxPackageDir)')">$(AppxPackageDir)\</AppxPackageDir>
    <AppxPackageUploadDir Condition="'$(AppxPackageUploadDir)' == ''">$(OutDir)$(AppxPackageUploadDirName)\$(AppxPackageDirName)\</AppxPackageUploadDir>
    <AppxPackageUploadDir Condition="!HasTrailingSlash('$(AppxPackageUploadDir)')">$(AppxPackageUploadDir)\</AppxPackageUploadDir>
    <AppxSymbolIntermediateDir Condition="'$(AppxSymbolIntermediateDir)' == ''">$(IntermediateOutputPath)Symbols</AppxSymbolIntermediateDir>
    <AppxPackagingInfoFile Condition="'$(AppxPackagingInfoFile)' == ''">$(IntermediateOutputPath)_pkginfo.txt</AppxPackagingInfoFile>
    <AppxDefaultHashAlgorithmId Condition="'$(AppxDefaultHashAlgorithmId)' == ''">sha256</AppxDefaultHashAlgorithmId>
    <AppxHashAlgorithmId Condition="'$(AppxHashAlgorithmId)' == ''">$(AppxDefaultHashAlgorithmId)</AppxHashAlgorithmId>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformMinVersion>
    <MakeAppxExeFullPath Condition="'$(MakeAppxExeFullPath)' == ''"></MakeAppxExeFullPath>
    <AppxPackageFileMap Condition="'$(AppxPackageFileMap)' == '' and '$(WindowsPackageType)'!='Sparse'">$(IntermediateOutputPath)package.map.txt</AppxPackageFileMap>
    <AppxWinMdCacheDir Condition="'$(AppxWinMdCacheDir)' == ''">$(IntermediateOutputPath).winmd_cache</AppxWinMdCacheDir>
    <ManagedWinmdInprocImplementation Condition="'$(ManagedWinmdInprocImplementation)' == ''">CLRHost.dll</ManagedWinmdInprocImplementation>
    <AppxManifestFileName Condition="'$(AppxManifestFileName)' == ''">AppxManifest.xml</AppxManifestFileName>
    <FinalAppxManifestName Condition="'$(FinalAppxManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxManifestName>
    <AppxPackageRecipe Condition="'$(AppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxPackageRecipe>
    <AppxUploadPackageRecipe Condition="'$(AppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxUploadPackageRecipe>
    <FinalAppxPackageRecipe Condition="'$(FinalAppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxPackageRecipe>
    <FinalAppxUploadPackageRecipe Condition="'$(FinalAppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxUploadPackageRecipe>
    <TempCertificateFilePath Condition="$(TempCertificateFilePath) == ''">$(IntermediateOutputPath)StoreKey_Temp.pfx</TempCertificateFilePath>
    <PublishAppxPackage Condition="'$(PublishAppxPackage)'==''">false</PublishAppxPackage>
    <GenerateAppxPackageOnBuild Condition="'$(GenerateAppxPackageOnBuild)'==''">false</GenerateAppxPackageOnBuild>
    <!-- Sparse packages always need to generate the msix package, as that is the only way they can be hooked up -->
    <_GenerateMsixPackage Condition="'$(GenerateAppxPackageOnBuild)'=='true' or '$(PublishAppxPackage)'=='true' or '$(WindowsPackageType)'=='Sparse'">true</_GenerateMsixPackage>
    <_GenerateMsixPackage Condition="'$(_GenerateMsixPackage)'==''">false</_GenerateMsixPackage>
    <AppxPackage Condition="'$(AppxPackage)'=='' and '$(WindowsPackageType)'!='None' and ('$(OutputType)' == 'WinExe' or '$(OutputType)' == 'Exe')">true</AppxPackage>
    <AppxPackage Condition="'$(AppxPackage)'==''">false</AppxPackage>

    <LayoutDir Condition="'$(LayoutDir)'==''">$(TargetDir)AppX</LayoutDir>

    <GenerateMsixAfterTarget Condition="'$(GenerateMsixAfterTarget)'=='' and '$(PublishAppxPackage)'=='true'">Publish</GenerateMsixAfterTarget>
    <GenerateMsixAfterTarget Condition="'$(GenerateMsixAfterTarget)'=='' and '$(WindowsPackageType)'=='Sparse'">CopyFilesToOutputDirectory</GenerateMsixAfterTarget>
    <GenerateMsixAfterTarget Condition="'$(GenerateMsixAfterTarget)'==''">PrepareMsixPackage</GenerateMsixAfterTarget>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxPackage)' == 'true'">
    <PackageAction>_GenerateAppxPackage</PackageAction>
  </PropertyGroup>

  <!-- Automatically include Package.appxmanifest if it exists but hasn't been explicitly
  included by the project -->
  <ItemGroup Condition="'@(AppxManifest)' == '' And Exists('Package.appxmanifest')">
    <AppxManifest Include="Package.appxmanifest">
      <SubType>Designer</SubType>
    </AppxManifest>
  </ItemGroup>

  <PropertyGroup>
    <!--
      The below table describes the available options for packaging and what they mean.
      These are controlled through the WindowsPackageType property.

        |   WindowsPackageType |  App Model Type | Produces .msix | Has Identity |
        |======================|=================|================|==============|
        |        None          |     Win32       |       No       |     No       |
        |        MSIX          |     Win32       |       Yes      |     Yes      |
        |       Sparse         |     Win32       |       No       |     Yes      |

       If there exists a Package.appxmanifest file, then we'll default into MSIX.
       If there is no Package.appxmanifest, then the default is None.
    -->
    <WindowsPackageType Condition="'$(WindowsPackageType)'=='' and Exists('Package.appxmanifest')">MSIX</WindowsPackageType>
    <WindowsPackageType Condition="'$(WindowsPackageType)'==''">None</WindowsPackageType>

    <WindowsAppContainer Condition="'$(WindowsPackageType)'=='MSIX'">true</WindowsAppContainer>
  </PropertyGroup>

  <Target Name="_ValidateWindowsPackageType">
    <PropertyGroup>
      <_ValidWindowsPackageTypes>None,MSIX,Sparse</_ValidWindowsPackageTypes>
    </PropertyGroup>

    <Error Condition="!$(_ValidWindowsPackageTypes.Contains('$(WindowsPackageType)'))"
           Text="'$(WindowsPackageType)' is not valid for the WindowsPackageType property. Value must be one of the following: $(_ValidWindowsPackageTypes)"/>

    <!--
      Provide an error if the user has specified properties that are not compatible
        (i.e. setting WindowsPackageType=None, but still setting GenerateAppxPackageOnBuild)
    -->
    <Error Condition="'$(WindowsPackageType)' == 'None' and '$(GenerateAppxPackageOnBuild)'=='true'"
          Text="Improper project configuration: WindowsPackageType is set to None, but GenerateAppxPackageOnBuild is set to true."/>
    <Error Condition="'$(WindowsPackageType)' == 'None' and '$(PublishAppxPackage)'=='true'"
          Text="Improper project configuration: WindowsPackageType is set to None, but PublishAppxPackage is set to true."/>
    <Error Condition="'$(WindowsPackageType)' == 'None' and '$(AppxPackage)'=='true'"
          Text="Improper project configuration: WindowsPackageType is set to None, but AppxPackage is set to true."/>
    <Error Condition="'$(WindowsPackageType)' == 'None' and '@(AppxManifest)'!=''"
          Text="Improper project configuration: WindowsPackageType is set to None, but a AppxManifest is specified."/>
    <Error Condition="'$(WindowsPackageType)' != 'None' and '@(AppxManifest)'==''"
          Text="Improper project configuration: no AppxManifest is specified, but WindowsPackageType is not set to $(WindowsPackageType)."/>
  </Target>

  <PropertyGroup>
    <PrepareForBuildDependsOn>
      $(PrepareForBuildDependsOn);
      _ValidateWindowsPackageType;
    </PrepareForBuildDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <PackageExtPrefix>msix</PackageExtPrefix>
    <PackageExtPrefix Condition="'$(TargetPlatformMinVersion)' &lt; '10.0.17200.0'">appx</PackageExtPrefix>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageExtension Condition="'$(AppxPackageExtension)' == ''">.$(PackageExtPrefix)</AppxPackageExtension>
    <AppxPackageEncryptedExtension Condition="'$(AppxPackageEncryptedExtension)' == ''">.e$(PackageExtPrefix)</AppxPackageEncryptedExtension>
    <AppxSymbolPackageExtension Condition="'$(AppxSymbolPackageExtension)' == ''">.$(PackageExtPrefix)sym</AppxSymbolPackageExtension>
    <AppxBundleExtension Condition="'$(AppxBundleExtension)' == ''">.$(PackageExtPrefix)bundle</AppxBundleExtension>
    <AppxBundleEncryptedExtension Condition="'$(AppxBundleEncryptedExtension)' == ''">.e$(PackageExtPrefix)bundle</AppxBundleEncryptedExtension>
    <AppxStoreContainerExtension Condition="'$(AppxStoreContainerExtension)' == ''">.$(PackageExtPrefix)upload</AppxStoreContainerExtension>
    <AppxIntermediateExtension Condition="'$(AppxIntermediateExtension)' == ''">.intermediate</AppxIntermediateExtension>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' == '' and Exists('$(PackageCertificateKeyFile)')">true</AppxPackageSigningEnabled>
    <AppxWinMdCacheEnabled Condition="'$(AppxWinMdCacheEnabled)' == ''">true</AppxWinMdCacheEnabled>
    <AppxHarvestWinmdRegistration Condition="'$(AppxHarvestWinmdRegistration)' == ''">true</AppxHarvestWinmdRegistration>
    <AppxGeneratePackageRecipeEnabled Condition="'$(AppxGeneratePackageRecipeEnabled)' == ''">true</AppxGeneratePackageRecipeEnabled>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == '' AND '$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)' &lt; '6.3'">
    <AppxUseResourceIndexerApi>false</AppxUseResourceIndexerApi>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
    <AppxUseResourceIndexerApi>true</AppxUseResourceIndexerApi>
  </PropertyGroup>

  <PropertyGroup>
    <PrepareMsixPackageDependsOn>
      $(PrepareMsixPackageDependsOn);
      _GetMsixSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      GetPackagingOutputs;
      _GetPackageProperties;
      _ComputeAppxPackagePayload;
      _GenerateAppxManifest;
      _GenerateAppxPackageRecipe;
    </PrepareMsixPackageDependsOn>
  </PropertyGroup>

  <!-- Hook to get our targets to run -->
  <PropertyGroup>
    <GenerateMsixPackageDependsOn Condition="'$(WindowsPackageType)'!='Sparse'">
      $(GenerateMsixPackageDependsOn);
      PrepareMsixPackage;
      _ComputeAppxPackageOutput;
      _GenerateAppxPackageFile;
      _GenerateAppxSymbolPackage;
      _CreateTestLayout;
      _AddWindowsInstallScriptToTestLayout;
    </GenerateMsixPackageDependsOn>

    <GenerateMsixPackageDependsOn Condition="'$(WindowsPackageType)'=='Sparse'">
      $(GenerateMsixPackageDependsOn);
      _GetMsixSdkToolPaths;
      GenerateProjectPriFile;
      _ComputeAppxPackageOutput;
      _GenerateAppxManifest;
      _GenerateAppxPackageFile;
    </GenerateMsixPackageDependsOn>
  </PropertyGroup>

  <Target Name="_CalculatePrepareMsixPackage" Returns="$(_PrepareMsixPackage)" AfterTargets="_ValidateWindowsPackageType">
    <PropertyGroup>
      <!--
        The prepare step of creating the package prepares the package layout so that the app can be debugged
        Sparse Packages and unpackaged apps don't need to prepare an msix package. Desktop or Universal packaged
        apps, or projects that specify AppxPackage to true, do need to do this.
      -->
      <_PrepareMsixPackage Condition="'$(_PrepareMsixPackage)' == '' and ('$(WindowsPackageType)' == 'Sparse' or '$(WindowsPackageType)'=='None')">false</_PrepareMsixPackage>
      <_PrepareMsixPackage Condition="'$(_PrepareMsixPackage)' == '' and '$(AppxPackage)'=='true'">true</_PrepareMsixPackage>
      <_PrepareMsixPackage Condition="'$(_PrepareMsixPackage)' == '' and ('$(OutputType)'=='WinExe' or '$(OutputType)'=='Exe')">true</_PrepareMsixPackage>
      <_PrepareMsixPackage Condition="'$(_PrepareMsixPackage)'==''">false</_PrepareMsixPackage>
    </PropertyGroup>
  </Target>

  <PropertyGroup>
    <PrepareForRunDependsOn>
      PrepareMsixPackage;
      $(PrepareForRunDependsOn);
    </PrepareForRunDependsOn>
  </PropertyGroup>

  <Target Name="PrepareMsixPackage"
          Condition="'$(_PrepareMsixPackage)' == 'true'"
          DependsOnTargets="$(PrepareMsixPackageDependsOn)" />

  <Target Name="GenerateMsixPackage"
          Condition="'$(_GenerateMsixPackage)'=='true' "
          AfterTargets="$(GenerateMsixAfterTarget)"
          DependsOnTargets="$(GenerateMsixPackageDependsOn)" />

  <PropertyGroup>
    <_GenerateAppxPackageDependsOn>
      $(GenerateMsixPackageDependsOn)
    </_GenerateAppxPackageDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)'!='true'">
      Build;
      $(_GenerateAppxPackageDependsOn);
    </_GenerateAppxPackageDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(PublishProfile)'!=''">
      Publish;
      $(_GenerateAppxPackageDependsOn);
    </_GenerateAppxPackageDependsOn>
  </PropertyGroup>
  <!-- This target maintained for compat with projects updating from Microsoft.AppxPackage.targets -->
  <Target Name="_GenerateAppxPackage" DependsOnTargets="$(_GenerateAppxPackageDependsOn)"/>

  <!-- If VCInstallPath properties aren't defined, we can get them from the tools install dir.
         If we *also* don't have the tools install dir, then we can at least attempt to get it from the
         VS install root, though that requires that we manually retrieve the version of MSVC. -->
  <UsingTask TaskName="GetLatestMSVCVersion" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <MSVCDirectoryPath ParameterType="System.String" Required="true" />
      <LatestMSVCVersion ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            // The versions of MSVC are expressed as directory names, which will automatically be sorted in version order
            // by virtue of the fact that they're sorted alphabetically, so we just want to return the last directory,
            // which will be the latest version.
            LatestMSVCVersion = new DirectoryInfo(Directory.EnumerateDirectories(MSVCDirectoryPath).Last()).Name;
]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="EnsurePdbCmfExeFullPath">
    <GetLatestMSVCVersion MSVCDirectoryPath="$(VsInstallRoot)\VC\Tools\MSVC" Condition="'$(VCToolsInstallDir)' == '' and '$(VsInstallRoot)' != ''">
      <Output TaskParameter="LatestMSVCVersion" PropertyName="LatestMSVCVersion"/>
    </GetLatestMSVCVersion>
    <PropertyGroup Condition="'$(VCToolsInstallDir)' == '' and '$(VsInstallRoot)' != ''">
      <VCToolsInstallDir Condition="'$(VCToolsInstallDir)' == ''">$(VsInstallRoot)\VC\Tools\MSVC\$(LatestMSVCVersion)\</VCToolsInstallDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(VCToolsInstallDir)' != ''">
      <_VCInstallPathHostArchitecture Condition="'$(PROCESSOR_ARCHITECTURE)' == 'x86'">X86</_VCInstallPathHostArchitecture>
      <_VCInstallPathHostArchitecture Condition="'$(PROCESSOR_ARCHITECTURE)' != 'x86'">X64</_VCInstallPathHostArchitecture>
      <PdbCmfx86ExeFullPath>$(VCToolsInstallDir)bin\Host$(_VCInstallPathHostArchitecture)\x86\mspdbcmf.exe</PdbCmfx86ExeFullPath>
      <PdbCmfx64ExeFullPath>$(VCToolsInstallDir)bin\Host$(_VCInstallPathHostArchitecture)\x64\mspdbcmf.exe</PdbCmfx64ExeFullPath>
    </PropertyGroup>
  </Target>

  <Target Name="_ValidatePresenceOfAppxManifestItems" Condition="'@(AppxManifest)@(CustomAppxManifest)'!=''">
    <ItemGroup>
      <CustomAppxManifest Include="@(Content)" Condition="'%(Identity)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <ReunionValidateAppxManifestItems AppxManifestItems="@(AppxManifest)" CustomAppxManifestItems="@(CustomAppxManifest)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IdentityName" PropertyName="AppxManifestIdentityName" />
      <Output TaskParameter="IdentityVersion" PropertyName="AppxManifestIdentityVersion" />
    </ReunionValidateAppxManifestItems>

    <ItemGroup>
      <SourceAppxManifest Include="@(AppxManifest)" Condition="'@(AppxManifest)' != ''" />
      <SourceAppxManifest Include="@(CustomAppxManifest)" Condition="'@(CustomAppxManifest)' != ''" />
    </ItemGroup>

    <PropertyGroup>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' == ''">false</_CustomAppxManifestUsed>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' != ''">true</_CustomAppxManifestUsed>
    </PropertyGroup>
  </Target>

  <Target Name="_GenerateAppxSymbolPackage" Condition="'@(PDBPayload)' != ''" Inputs="$(MSBuildAllProjects);@(PDBPayload);@(FinalAppxManifest)" Outputs="$(AppxSymbolPackageOutput)" DependsOnTargets="EnsurePdbCmfExeFullPath">
    <PropertyGroup>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>

    <ReunionGenerateAppxSymbolPackage MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)"
                               InputPdbs="@(PDBPayload)"
                               ProjectName="$(MSBuildProjectName)"
                               StripPrivateSymbols="$(StripPrivateSymbols)"
                               IntermediateSymbolRoot="$(AppxSymbolIntermediateDir)"
                               ReconstituteFastlinkPdbs="$(ReconstituteFastlinkPdbs)"
                               AppxSymbolPackageOutput="$(AppxSymbolPackageOutput)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="OutputPdbs" ItemName="OutputPdbFiles" />
    </ReunionGenerateAppxSymbolPackage>

    <ItemGroup>
      <FinalAppxSymbolPackageItem Include="$(AppxSymbolPackageOutput)" />
      <PackagingFileWrites Include="@(FinalAppxSymbolPackageItem)" />
      <FileWrites Include="@(OutputPdbFiles)" />
      <PackagingDirectoryWrites Include="$(AppxSymbolIntermediateDir)" />
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(AppxSymbolPackageOutput)" />
  </Target>

  <Target Name="_GetMsixSdkToolPaths">
    <ReunionGetSdkFileFullPath FileName="MakeAppx.exe"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakeAppxExeFullPath" />
    </ReunionGetSdkFileFullPath>

    <Message Importance="low" Text="MakeAppxExeFullPath: $(MakeAppxExeFullPath)" />

    <ReunionGetSdkFileFullPath FileName="signtool.exe"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="SignAppxPackageExeFullPath" />
    </ReunionGetSdkFileFullPath>

    <Message Importance="low" Text="SignAppxPackageExeFullPath: $(SignAppxPackageExeFullPath)" />
  </Target>

  <Target Name="_DeleteAppxOutputFolderIfNecessary" Condition="('$(BuildingInsideVisualStudio)' != 'true' or '$(AppxAutoIncrementPackageRevision)' != 'true') and Exists($(AppxPackageTestDir))">
    <RemoveDir Directories="$(AppxPackageTestDir)" />
    <Message Importance="low" Text="Deleting $(AppxPackageTestDir)" />
  </Target>

  <Target Name="_GenerateAppxPackageFile" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);@(AppxPackagePayload);$(PackageCertificateKeyFile)" Outputs="$(AppxPackageOutput)" DependsOnTargets="_GetMsixSdkToolPaths;_DeleteAppxOutputFolderIfNecessary">
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ReunionRemovePayloadDuplicates Inputs="@(AppxPackagePayload)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_DedupedAppxPackagePayload" />
    </ReunionRemovePayloadDuplicates>

    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)"/>
      <AppxPackagePayload Include="@(_DedupedAppxPackagePayload)"/>
      <_DedupedAppxPackagePayload Remove="@(_DedupedAppxPackagePayload)"/>
    </ItemGroup>

    <WriteLinesToFile
      Condition="'$(WindowsPackageType)'!='Sparse'"
      File="$(AppxPackageFileMap)"
      Lines="[Files];@(FinalAppxManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');@(AppxPackagePayload->'%22%(Identity)%22 %22%(TargetPath)%22')"
      Overwrite="true" />

    <ItemGroup Condition="'$(WindowsPackageType)'!='Sparse'">
      <FileWrites Include="$(AppxPackageFileMap)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(WindowsPackageType)'=='Sparse'">
      <MsixContentDirectory Condition="'$(MsixContentDirectory)'==''">$(TargetDir)</MsixContentDirectory>
    </PropertyGroup>

    <ReunionMakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="false"
                  EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  ContentDirectory="$(MsixContentDirectory)"
                  FileMap="$(AppxPackageFileMap)"
                  Output="$(AppxPackageOutput)"
                  VsTelemetrySession="$(VsTelemetrySession)" />

    <ItemGroup>
      <FinalAppxPackageItem Include="$(AppxPackageOutput)" />
      <AllBuiltSideloadPackages Include="$(AppxPackageOutput)"/>
      <FileWrites Include="@(FinalAppxPackageItem)" />
    </ItemGroup>

    <WriteLinesToFile File="$(AppxPackagingInfoFile)" Overwrite="true" Lines="%(FinalAppxPackageItem.FullPath)" />

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

    <Message Importance="high" Text="$(MSBuildProjectName) -> %(FinalAppxPackageItem.FullPath)" />

    <ReunionSignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="@(FinalAppxPackageItem)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     ExportCertificate="true"
                     VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </ReunionSignAppxPackage>

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(ResolvedThumbprint)" />
  </Target>

  <Target Name="_AddWindowsInstallScriptToTestLayout">
    <PropertyGroup>
      <_PowershellScriptLocation Condition="'$(_PowershellScriptLocation)'==''">$(MSBuildThisFileDirectory)AppDevPackageScripts\</_PowershellScriptLocation>
    </PropertyGroup>
    <ItemGroup>
      <_PowerShellScriptsSource Include="$(_PowershellScriptLocation)Add-AppDevPackage.ps1" />
      <_PowerShellScriptsSource Include="$(_PowershellScriptLocation)Install.ps1" />
      <_PowerShellScriptsSource Include="$(_PowershellScriptLocation)**\Add-AppDevPackage.psd1" />
    </ItemGroup>

    <ItemGroup>
      <_PowerShellScriptsDestination Include="@(_PowerShellScriptsSource->'$(AppxPackageTestDir)%(RecursiveDir)%(FileName)%(Extension)')" />
    </ItemGroup>

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="true" SourceFiles="@(_PowerShellScriptsSource)" DestinationFiles="@(_PowerShellScriptsDestination)" ContinueOnError="$(ContinueOnError)" />

    <ItemGroup>
      <PackagingFileWrites Include="@(_PowerShellScriptsDestination)" />
    </ItemGroup>
  </Target>

  <Target Name="_CreateTestLayout">
    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(FileName)%(Extension)')" />
    </ItemGroup>

    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>

    <Message Importance="low" Text="Test Layout: %(_TestLayoutTargetFiles.FullPath)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_TestLayoutSourceFiles)" DestinationFiles="@(_TestLayoutTargetFiles)" />

    <ItemGroup>
      <PackagingFileWrites Include="@(_TestLayoutTargetFiles)"/>
      <PackagingDirectoryWrites Include="$(AppxPackageTestDir)" />
    </ItemGroup>
  </Target>

  <Target Name="_ComputeAppxPackageOutput">
    <ReadLinesFromFile File="$(_MultipleQualifiersPerDimensionFoundPath)" Condition="'$(AppxBundle)' == 'Auto' and Exists($(_MultipleQualifiersPerDimensionFoundPath))">
      <Output TaskParameter="Lines" PropertyName="_MultipleQualifiersPerDimensionFound" />
    </ReadLinesFromFile>

    <PropertyGroup Condition="'$(AppxBundle)' == 'Auto'">
      <_MultipleQualifiersPerDimensionFound Condition="'$(_MultipleQualifiersPerDimensionFound)' != 'true'">false</_MultipleQualifiersPerDimensionFound>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.0'">
      <ProduceAppxBundle>false</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' != '8.0'">
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Auto'">$(_MultipleQualifiersPerDimensionFound)</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Never'">false</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Always'">true</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(WindowsPackageType)'=='Sparse'">
      <AppxPackageName>$(TargetName)</AppxPackageName>
      <AppxPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' != ''">
      <AppxPackageNameNeutral>$(AppxPackageName)</AppxPackageNameNeutral>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' == ''">
      <AppxPackageNameNeutral>$(ProjectName)_$(AppxManifestIdentityVersion)</AppxPackageNameNeutral>
      <_AppxPackageConfiguration Condition="'$(Configuration)' != 'Release'">_$(Configuration)</_AppxPackageConfiguration>
      <AppxPackageName>$(AppxPackageNameNeutral)_$(Platform)$(_AppxPackageConfiguration)</AppxPackageName>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxStoreContainer)' == '' and '$(ProduceAppxBundle)' == 'false'">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageName)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageTestDir)' == ''">
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\</AppxPackageTestDir>
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\</AppxPackageTestDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageTestExternalPackagesDir)' == ''">
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageOutput)' == ''">
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageEncryptedExtension)</AppxPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == ''">
      <AppxSymbolPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleDir Condition="'$(AppxBundleDir)' == ''">$(IntermediateOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxBundleDir>
      <AppxBundleDir Condition="!HasTrailingSlash('$(AppxBundleDir)')">$(AppxBundleDir)\</AppxBundleDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxMainPackageOutput)' == ''">
      <AppxMainPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxMainPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxResourcePackOutputBase)' == ''">
      <AppxResourcePackOutputBase>$(TargetDir)$(AppxPackageNameNeutral)</AppxResourcePackOutputBase>
    </PropertyGroup>
  </Target>


  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>
      BeforeGenerateAppxManifest;
      $(_GenerateAppxManifestDependsOn);
      _GetAppxManifestSchemaItems;
      _GenerateAdditionalFrameworkSDKReference;
      _GetRecursiveResolvedSDKReferences;
      _CalculateInputsForGenerateCurrentProjectAppxManifest;
      _GenerateCurrentProjectAppxManifest;
      _CreateFinalAppxManifestItem;
      AfterGenerateAppxManifest
    </_GenerateAppxManifestDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_GenerateAppxPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxPackageRecipe;
      _GenerateAppxPackageRecipeFile
    </_GenerateAppxPackageRecipeDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <AllOutputGroupsDependsOn>
      $(AllOutputGroupsDependsOn);
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </AllOutputGroupsDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <CopyLocalFilesOutputGroupDependsOn>
      $(CopyLocalFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyLocalFilesOutputGroupDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <ComFilesOutputGroupDependsOn>
      $(ComFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </ComFilesOutputGroupDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <CopyWinmdArtifactsOutputGroupDependsOn>
      $(CopyWinmdArtifactsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyWinmdArtifactsOutputGroupDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <GetPackagingOutputsDependsOn>
      $(GetPackagingOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      GetPriOutputs;
    </GetPackagingOutputsDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_GetPackagePropertiesDependsOn>
      $(_GetPackagePropertiesDependsOn);
      _GetProjectArchitecture;
      _GetRecursiveProjectArchitecture;
      _GetPackageArchitecture;
      _CalculateAppxBundleProperties;
    </_GetPackagePropertiesDependsOn>
  </PropertyGroup>

  <!-- Mapping between OS version (6.*) and marketing version string. -->
  <!-- There is no guarantee that NTVersion always consists of first two parts of OSVersion, hence a separate field. -->
  <ItemGroup>
    <PlatformVersionDescription Include="Windows 8.0">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.0</TargetPlatformVersion>
      <OSDescription>Windows 8.0</OSDescription>
      <OSVersion>6.2.1</OSVersion>
      <NTVersion>6.2</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.1">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows 8.1</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.2">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.2</TargetPlatformVersion>
      <OSDescription>Windows 8.2</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="UAP 1.0">
      <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
      <TargetPlatformVersion>0.8.0.0</TargetPlatformVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>7.0</TargetPlatformVersion>
      <TargetPlatformMinVersion>7.0</TargetPlatformMinVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>10.0.17134.0</TargetPlatformVersion>
      <TargetPlatformMinVersion>10.0.17134.0</TargetPlatformMinVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>10.0.17763.0</TargetPlatformVersion>
      <TargetPlatformMinVersion>10.0.17134.0</TargetPlatformMinVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>10.0.18362.0</TargetPlatformVersion>
      <TargetPlatformMinVersion>10.0.17134.0</TargetPlatformMinVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>10.0.19041.0</TargetPlatformVersion>
      <TargetPlatformMinVersion>10.0.17134.0</TargetPlatformMinVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
  </ItemGroup>

  <Target Name="_GenerateAdditionalFrameworkSDKReference">
    <ItemGroup>
      <_IntermediateFrameworkSdkReference Include="@(AppxPackageRegistration)"
         Condition="'@(AppxPackageRegistration)' != ''
                    AND ('$(Configuration)' == '%(AppxPackageRegistration.Configuration)' OR '%(AppxPackageRegistration.Configuration)' == '')
                    AND ('$(Platform)' == '%(AppxPackageRegistration.Architecture)' OR '%(AppxPackageRegistration.Configuration)' == '')">
        <SDKName Condition="%(AppxPackageRegistration.Name) != ''">%(AppxPackageRegistration.Name)</SDKName>
        <SDKName Condition="%(AppxPackageRegistration.Name) == ''">%(AppxPackageRegistration.Filename)</SDKName>
        <TargetedSDKConfiguration>%(AppxPackageRegistration.Configuration)</TargetedSDKConfiguration>
        <TargetedSDKArchitecture>%(AppxPackageRegistration.Architecture)</TargetedSDKArchitecture>
        <AppxLocation>%(AppxPackageRegistration.Identity)</AppxLocation>
      </_IntermediateFrameworkSdkReference>

      <FrameworkSdkReference Include="@(_IntermediateFrameworkSdkReference)">
        <FrameworkIdentity>Name = %(_IntermediateFrameworkSdkReference.SDKName), MinVersion = %(_IntermediateFrameworkSdkReference.Version), Publisher = %(_IntermediateFrameworkSdkReference.Publisher)</FrameworkIdentity>
      </FrameworkSdkReference>
    </ItemGroup>
  </Target>

  <Target Name="_GenerateAppxManifest" DependsOnTargets="$(_GenerateAppxManifestDependsOn)" />

  <PropertyGroup Condition="'$(WindowsPackageType)'=='Sparse'">
    <GenerateReunionWin32ManifestDependsOn>
      $(GenerateReunionWin32ManifestDependsOn);
      _GenerateAppxManifest;
    </GenerateReunionWin32ManifestDependsOn>
  </PropertyGroup>

  <Target Name="BeforeGenerateAppxManifest" />
  <Target Name="AfterGenerateAppxManifest" />

  <Target Name="_GetRecursiveResolvedSDKReferences">
    <ItemGroup>
      <_UnfilteredRecursiveResolvedSDKReference Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'GetResolvedSDKReferences'" />
    </ItemGroup>

    <ReunionRemoveDuplicateSDKReferences Inputs="@(_UnfilteredRecursiveResolvedSDKReference)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="RecursiveResolvedSDKReference" />
    </ReunionRemoveDuplicateSDKReferences>

    <ItemGroup>
      <FrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' != ''" />
    </ItemGroup>

    <ItemGroup>
      <NonFrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' == ''" />
    </ItemGroup>

    <!-- Add non-framework SDK versions to manifest build metadata. -->
    <ItemGroup>
      <AppxManifestMetadata Include="@(NonFrameworkSdkReference)">
        <Name>%(NonFrameworkSdkReference.SimpleName)</Name>
        <Version>%(NonFrameworkSdkReference.Version)</Version>
      </AppxManifestMetadata>
    </ItemGroup>

    <ReunionGetFrameworkSdkPackages FrameworkSdkReferences="@(FrameworkSdkReference)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkSdkPackage" />
    </ReunionGetFrameworkSdkPackages>
  </Target>

  <Target Name="_CalculateInputsForGenerateCurrentProjectAppxManifest">
    <ItemGroup Condition="'$(AppxHarvestWinmdRegistration)' == 'true'">
      <_WinmdFilesFromWinmdArtifacts Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                                                                and '%(PackagingOutputs.OutputGroup)' == 'CopyWinmdArtifactsOutputGroup'
                                                                                and '%(PackagingOutputs.ProjectName)' != '$(ProjectName)'
                                                                                and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'"/>
      <_WinmdFilesFromReferences Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd' and '%(PackagingOutputs.OutputGroup)' == 'CopyLocalFilesOutputGroup' and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromOtherGroups Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                                                            and '%(PackagingOutputs.OutputGroup)' != 'CopyWinmdArtifactsOutputGroup'
                                                                            and '%(PackagingOutputs.OutputGroup)' != 'CopyLocalFilesOutputGroup'
                                                                            and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'
                                                                            and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromSDKs Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd' and '%(PackagingOutputs.ResolvedFrom)' == 'GetSDKReferenceFiles' and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
    </ItemGroup>

    <ReunionRemovePayloadDuplicates Inputs="@(_WinmdFilesFromWinmdArtifacts);@(_WinmdFilesFromReferences);@(_WinmdFilesFromOtherGroups);@(_WinmdFilesFromSDKs)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </ReunionRemovePayloadDuplicates>

    <ItemGroup>
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifest);@(AppxManifestSchema);$(PackageCertificateKeyFile);@(_AppxWinmdFilesToHarvest);$(_QualifiersPath)" />
    </ItemGroup>
  </Target>

  <Target Name="_GenerateCurrentProjectAppxManifest"
          Condition="Exists(@(AppxManifest))"
          Inputs="$(MSBuildAllProjects);@(_GenerateCurrentProjectAppxManifestInput)"
          Outputs="$(FinalAppxManifestName)"
          DependsOnTargets="_GetDefaultResourceLanguage">
    <PropertyGroup>
      <ApplicationEntryPoint Condition="'$(ApplicationEntryPoint)'== '' and '$(WindowsPackageType)'=='MSIX'">Windows.FullTrustApplication</ApplicationEntryPoint>
    </PropertyGroup>
    <ItemGroup>
      <AppxManifestMetadata Include="$(MakePriExeFullPath)" />

      <!--
        Set the default TargetDeviceFamily metadata to either Universal or Desktop. Referencing extension SDKs (Xbox, HoloLens, IOT, etc)
        should add their respectable TargetDeviceFamily to this metadata.
        For legacy UAP projects, the target platform identifier is UAP, so those default to universal. To simplify and remove concept
        count, all Windows projects moving forward will have a TargetPlatformIdenitifer of Windows. The WindowsAppContainer property
        is used to switch between a project that targets the Universal device family and one that doesn't.

        Note: C++ Reunion projects will also have TargetDeviceFamily=Windows.Universal as they reuse the C++
        Universal App project system and thus TargetPlatformIdentifier==UAP.
      -->
      <TargetDeviceFamily Include="Windows.Universal" Condition="'$(TargetPlatformIdentifier)'=='UAP'">
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
      </TargetDeviceFamily>
      <TargetDeviceFamily Include="Windows.Desktop" Condition="'$(TargetPlatformIdentifier)'=='Windows'">
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
      </TargetDeviceFamily>
    </ItemGroup>

    <Error Condition="'$(AppxPackageSigningEnabled)' != 'true' and '$(WindowsPackageType)'=='Sparse'"
           Text="Sparse packages are required to be signed in order to be registered. Please specify a certificate using the PackageCertificateKeyFile property."/>

    <ReunionGenerateAppxManifest AppxManifestInput="@(AppxManifest)"
                          AppxManifestOutput="$(FinalAppxManifestName)"
                          ApplicationExecutableName="$(TargetName)"
                          FrameworkSdkReferences="@(FrameworkSdkReference)"
                          NonFrameworkSdkReferences="@(NonFrameworkSdkReference)"
                          CertificateThumbprint="$(PackageCertificateThumbprint)"
                          CertificateFile="$(PackageCertificateKeyFile)"
                          DefaultResourceLanguage="$(DefaultResourceLanguage)"
                          QualifiersPath="$(_QualifiersPath)"
                          PackageArchitecture="$(PackageArchitecture)"
                          SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)"
                          WinmdFiles="@(_AppxWinmdFilesToHarvest)"
                          ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)"
                          PackageSigningEnabled="$(AppxPackageSigningEnabled)"
                          EnableSigningChecks="$(EnableSigningChecks)"
                          ManifestMetadata="@(AppxManifestMetadata)"
                          MetadataNamespaceUri="$(MetadataNamespaceUri)"
                          TargetDeviceFamilies="@(TargetDeviceFamily)"
                          VsTelemetrySession="$(VsTelemetrySession)"
                          WinmdCacheEnabled="$(AppxWinMdCacheEnabled)"
                          WinmdCacheDir="$(AppxWinMdCacheDir)"
                          RestrictedCapabilitiesNamespaceUri="$(RestrictedCapabilitiesNamespaceUri)"
                          DesktopNamespaceUri="$(DesktopNamespaceUri)"
                          Uap10NamespaceUri="$(Uap10NamespaceUri)"
                          EntryPoint="$(ApplicationEntryPoint)"
                          WindowsPackageType="$(WindowsPackageType)">
        <Output TaskParameter="Identity" PropertyName="MsixIdentity"/>
        <Output TaskParameter="IdentityPublisher" PropertyName="MsixIdentityPublisher"/>
        <Output TaskParameter="ApplicationId" PropertyName="MsixApplicationId"/>
      </ReunionGenerateAppxManifest>

    <ItemGroup Condition="'$(WindowsPackageType)'=='Sparse'">
      <SxSManifestLinesForSparsePackage Include="&lt;assembly manifestVersion='1.0' xmlns='urn:schemas-microsoft-com:asm.v1'&gt;"/>
      <SxSManifestLinesForSparsePackage Include="&lt;msix xmlns='urn:schemas-microsoft-com:msix.v1'"/>
      <SxSManifestLinesForSparsePackage Include="publisher='$(MsixIdentityPublisher)'"/>
      <SxSManifestLinesForSparsePackage Include="packageName='$(MsixIdentity)'"/>
      <SxSManifestLinesForSparsePackage Include="applicationId='$(MsixApplicationId)' /&gt;"/>
      <SxSManifestLinesForSparsePackage Include="&lt;/assembly&gt;"/>
    </ItemGroup>

    <WriteLinesToFile Condition="'$(WindowsPackageType)'=='Sparse'"
                      File="$(IntermediateOutputPath)msix.generated.manifest"
                      Overwrite="true"
                      Lines="@(SxSManifestLinesForSparsePackage)" />

    <ItemGroup Condition="'$(WindowsPackageType)'=='Sparse'">
      <ReunionWin32Manifest Include="$(IntermediateOutputPath)msix.generated.manifest"/>
      <FileWrites Include="$(IntermediateOutputPath)msix.generated.manifest"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Conditon="'$(AppxWinMdCacheEnabled)' == 'true'" Include="$(AppxWinMdCacheDir)\**\*"></FileWrites>
    </ItemGroup>

    <Message Importance="low" Text="@(AppxManifest) -> $(FinalAppxManifestName)" />

</Target>

  <!-- In order for incremental build and clean to work correctly we are creating build item @(FinalAppxManifest) and @(FileWrites) in the target which always executes. -->
  <Target Name="_CreateFinalAppxManifestItem">
    <ItemGroup>
      <FinalAppxManifest Include="$(FinalAppxManifestName)" />
    </ItemGroup>

    <ItemGroup>
      <FileReads Include="@(_GenerateCurrentProjectAppxManifestInput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxManifest)"/>
    </ItemGroup>
  </Target>

  <Target Name="_GetAppxManifestSchemaItems" Condition="'@(AppxManifestSchema)' == ''">
    <ItemGroup>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <!-- Define AppxValidateStoreManifest based on whether we ended up with any StoreManifestSchemas or not.  This keeps the logic agnostic about which TargetPlatform/Version supports validating the Store manifest. -->
    <PropertyGroup>
      <AppxValidateStoreManifest Condition="'$(AppxValidateStoreManifest)' == '' and '@(StoreManifestSchema)' != ''">true</AppxValidateStoreManifest>
    </PropertyGroup>

    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == '' and '$(SDKIdentifier)' != ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2012/build</MetadataNamespaceUri>
      <RestrictedCapabilitiesNamespaceUri Condition="'$(RestrictedCapabilitiesNamespaceUri)' == ''">http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities</RestrictedCapabilitiesNamespaceUri>
      <DesktopNamespaceUri Condition="'$(DesktopNamespaceUri)'==''">http://schemas.microsoft.com/appx/manifest/desktop/windows10</DesktopNamespaceUri>
      <Uap10NamespaceUri Condition="'$(Uap10NamespaceUri)'==''">http://schemas.microsoft.com/appx/manifest/uap/windows10/10</Uap10NamespaceUri>
    </PropertyGroup>
  </Target>

  <Target Name="_GetProjectArchitecture" Returns="@(ProjectArchitecture)">
    <PropertyGroup>
      <_ProjectArchitectureOutput>Invalid</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'AnyCPU'">neutral</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x86'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'Win32'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x64'">x64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm'">arm</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm64'">arm64</_ProjectArchitectureOutput>
    </PropertyGroup>

    <ItemGroup>
      <ProjectArchitecture Include="$(_ProjectArchitectureOutput)" />
    </ItemGroup>
  </Target>

  <Target Name="CopyLocalFilesOutputGroup" DependsOnTargets="$(CopyLocalFilesOutputGroupDependsOn)" Returns="@(CopyLocalFilesOutputGroupOutput)">
    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml' or '$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' == 'true'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>

    <!-- In case of Winmd files, we may not get implementation file as separate CopyLocal file (if exist), so we are extracting it here. -->
    <ItemGroup>
      <_WinmdWithImplementation Include="@(CopyLocalFilesOutputGroupOutput)" Condition="'%(CopyLocalFilesOutputGroupOutput.Extension)' == '.winmd' AND '%(CopyLocalFilesOutputGroupOutput.Filename)' != 'platform' AND '%(CopyLocalFilesOutputGroupOutput.Implementation)' != ''"/>

      <!-- Determine if any existing copy-local item has already satisfied the implementation -->
      <_WinmdWithImplementationTargetPath Include="@(_WinmdWithImplementation->'%(DestinationSubDirectory)%(Implementation)')">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_WinmdWithImplementationTargetPath>
      <_CopyLocalFilesOutputGroupOutputTargetPath Include="@(CopyLocalFilesOutputGroupOutput->'%(TargetPath)')"/>
      <!-- intersect on targetpath -->
      <_WinmdSatifiedImplementation Include="@(_WinmdWithImplementationTargetPath)" Condition="'@(_WinmdWithImplementationTargetPath)' == '@(_CopyLocalFilesOutputGroupOutputTargetPath)' AND '%(Identity)' != ''"/>
      <_WinmdWithImplementation Remove="@(_WinmdSatifiedImplementation->'%(OriginalItemSpec)')" />
    </ItemGroup>

    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)">
        <TargetPath>%(_WinmdWithImplementation.DestinationSubDirectory)%(_WinmdWithImplementation.Implementation)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>
  </Target>

  <Target Name="ComFilesOutputGroup" DependsOnTargets="$(ComFilesOutputGroupDependsOn)" Returns="@(ComFilesOutputGroupOutputs)">
    <ItemGroup>
      <ComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)" >
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)" >
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(NativeReferenceFile)" >
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
    </ItemGroup>
  </Target>

  <Target Name="CopyWinmdArtifactsOutputGroup" DependsOnTargets="$(CopyWinmdArtifactsOutputGroupDependsOn)" Returns="@(CopyWinmdArtifactsOutputGroupOutputs)">
    <ItemGroup>
      <CopyWinmdArtifactsOutputGroupOutputs Include="@(FinalWinmdExpArtifacts ->'%(FullPath)')">
        <TargetPath>%(FinalWinmdExpArtifacts.DestinationSubDirectory)%(FinalWinmdExpArtifacts.Filename)%(FinalWinmdExpArtifacts.Extension)</TargetPath>
      </CopyWinmdArtifactsOutputGroupOutputs>
    </ItemGroup>
  </Target>

  <Target Name="__GetPublishItems" DependsOnTargets="ComputeFilesToPublish" Returns="@(_PublishItem)">
    <ItemGroup>
      <_PublishItem Include="@(ResolvedFileToPublish->'%(FullPath)')" TargetPath="%(ResolvedFileToPublish.RelativePath)" OutputGroup="__GetPublishItems" />
    </ItemGroup>
  </Target>

  <!--
    GetPackagingOutputs is a target, that like, GetPriOutputs, invokes well-known targets that ship with MSBuild,
    to populate certain OutputGroups. This file also defines certain OutputGroups that are only relevant for
    MSIX packaging (i.e. ComFilesOutputGroup and CopyWinmdArtifactsOutputGroup).

    This target depends on the GetPriOutputs target running, since pri files are also part of the msix packaging
    process.
  -->
  <Target Name="GetPackagingOutputs" Returns="@(PackagingOutputs)" DependsOnTargets="$(GetPackagingOutputsDependsOn)">
    <PropertyGroup>
      <!--
        For .NET applications, we always need to include publish items output group, because this includes the exe. We ignore libraries since publish
        is an application verb and library projects are built for AnyCPU, so including publish output groups will include native assets for every platform
        instead of just the one being built for.
      -->
      <IncludePublishItemsOutputGroup Condition="'$(IncludePublishItemsOutputGroup)'=='' and '$(UsingMicrosoftNETSdk)'=='true' and '$(OutputType)'=='WinExe' ">true</IncludePublishItemsOutputGroup>
      <IncludeBuiltProjectOutputGroup Condition="'$(IncludeBuiltProjectOutputGroup)' == ''">true</IncludeBuiltProjectOutputGroup>
      <IncludeCopyLocalFilesOutputGroup Condition="'$(IncludeCopyLocalFilesOutputGroup)' == ''">true</IncludeCopyLocalFilesOutputGroup>
      <IncludeContentFilesProjectOutputGroup Condition="'$(IncludeContentFilesProjectOutputGroup)' == ''">true</IncludeContentFilesProjectOutputGroup>

      <IncludeDebugSymbolsProjectOutputGroup Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == ''">true</IncludeDebugSymbolsProjectOutputGroup>
      <IncludeDocumentationProjectOutputGroup Condition="'$(IncludeDocumentationProjectOutputGroup)' == ''">false</IncludeDocumentationProjectOutputGroup>
      <IncludeSatelliteDllsProjectOutputGroup Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == ''">false</IncludeSatelliteDllsProjectOutputGroup>
      <IncludeSourceFilesProjectOutputGroup Condition="'$(IncludeSourceFilesProjectOutputGroup)' == ''">false</IncludeSourceFilesProjectOutputGroup>
      <IncludeSGenFilesOutputGroup Condition="'$(IncludeSGenFilesOutputGroup)' == ''">false</IncludeSGenFilesOutputGroup>
      <IncludeOptionalProjectsOutputGroup Condition="'$(IncludeOptionalProjectsOutputGroup)' == ''">true</IncludeOptionalProjectsOutputGroup>
      <IncludeComFilesOutputGroup Condition="'$(IncludeComFilesOutputGroup)' == ''">false</IncludeComFilesOutputGroup>
      <IncludeCustomOutputGroupForPackaging Condition="'$(IncludeCustomOutputGroupForPackaging)' == ''">false</IncludeCustomOutputGroupForPackaging>
      <IncludeCopyWinmdArtifactsOutputGroup Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == ''">true</IncludeCopyWinmdArtifactsOutputGroup>
      <IncludeSDKRedistOutputGroup Condition="'$(IncludeSDKRedistOutputGroup)' == ''">true</IncludeSDKRedistOutputGroup>
      <IncludeGetResolvedSDKReferences Condition="'$(IncludeGetResolvedSDKReferences)' == ''">true</IncludeGetResolvedSDKReferences>
    </PropertyGroup>

    <CallTarget Targets="BuiltProjectOutputGroup" Condition="'$(IncludeBuiltProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_BuiltProjectOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(PublishReadyToRun)'!='true'">
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <!-- Ignore .dll files when PublishReadyToRun is set to true, otherwise we will get payload duplicate errors -->
    <ItemGroup Condition="'$(PublishReadyToRun)'=='true'">
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)" Condition="'%(Extension)'!='.dll'">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="__GetPublishItems" Condition="'$(IncludePublishItemsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_PublishItemsOutputGroupOutput" />
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_PublishItemsOutputGroupOutput)">
        <OutputGroup>PublishItemsOutputGroupOutput</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DebugSymbolsProjectOutputGroup" Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DebugSymbolsProjectOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_DebugSymbolsProjectOutputGroupOutput.FinalOutputPath)">
        <OutputGroup>DebugSymbolsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DocumentationProjectOutputGroup" Condition="'$(IncludeDocumentationProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DocumentationProjectOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_DocumentationProjectOutputGroupOutput)">
        <OutputGroup>DocumentationProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SatelliteDllsProjectOutputGroup" Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SatelliteDllsProjectOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SatelliteDllsProjectOutputGroupOutput)">
        <OutputGroup>SatelliteDllsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SourceFilesProjectOutputGroup" Condition="'$(IncludeSourceFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFilesProjectOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SourceFilesProjectOutputGroupOutput)">
        <OutputGroup>SourceFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SGenFilesOutputGroup" Condition="'$(IncludeSGenFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SGenFilesOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SGenFilesOutputGroupOutput)">
        <OutputGroup>SGenFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyLocalFilesOutputGroup" Condition="'$(IncludeCopyLocalFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyLocalFilesOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(PublishReadyToRun)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)" Condition="'%(Extension)'!='.pri'">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <!-- Ignore .dll files when PublishReadyToRun is set to true, otherwise we will get payload duplicate errors -->
    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)" Condition="'%(Extension)'!='.pri' and '%(Extension)'!='.dll'">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="ComFilesOutputGroup" Condition="'$(IncludeComFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ComFilesOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ComFilesOutputGroupOutput)">
        <OutputGroup>ComFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyWinmdArtifactsOutputGroup" Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyWinmdArtifactsOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyWinmdArtifactsOutputGroupOutput)">
        <OutputGroup>CopyWinmdArtifactsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent)' == 'true'">
      <!-- If extension SDK contains both XAML and XBF files, do not package XBF files from SDK -->
      <_SDKRedistRedundantXBF Include="@(_SDKRedistOutputGroupOutput->'%(RootDir)%(Directory)%(Filename).xbf')"
                              Condition="'%(Extension)'=='.xaml'" />
      <_SDKRedistOutputGroupOutput Remove="@(_SDKRedistRedundantXBF)" />
    </ItemGroup>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SDKRedistOutputGroupOutput)">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Remove="@(RemoveSdkFilesFromAppxPackage)" />
    </ItemGroup>

    <ItemGroup Condition="'$(DisableEmbeddedXbf)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_CustomOutputGroupForPackagingOutput Remove="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'"/>
    </ItemGroup>

    <ReunionExpandPayloadDirectories Inputs="@(_PackagingOutputsUnexpanded)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsExpanded" />
    </ReunionExpandPayloadDirectories>

    <CallTarget Targets="GetResolvedSDKReferences" Condition="'$(IncludeGetResolvedSDKReferences)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetResolvedSDKReferencesOutputWithoutMetadata"/>
    </CallTarget>

    <ItemGroup>
      <_GetResolvedSDKReferencesOutput Include="@(_GetResolvedSDKReferencesOutputWithoutMetadata)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_GetResolvedSDKReferencesOutput>
    </ItemGroup>

    <CallTarget Targets="_GetProjectArchitecture">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectArchitecture" />
    </CallTarget>

    <ItemGroup>
      <_ProjectArchitectureItem Include="@(_ProjectArchitecture)">
        <OutputGroup>_GetProjectArchitecture</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_ProjectArchitectureItem>
    </ItemGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>

    <MSBuild
      Projects="@(ProjectReferenceWithConfiguration)"
      Targets="GetPackagingOutputs"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)"
      Condition="'@(ProjectReferenceWithConfiguration)' != ''
                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true'
                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'"
      ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackagingOutputsFromOtherProjects"/>
    </MSBuild>

    <ItemGroup>
      <_PackagingOutputsOutsideLayout Include="@(ProjectPriFile)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsExpanded)" />
      <_PackagingOutputsOutsideLayout Include="@(PriOutputs)" />
      <_PackagingOutputsOutsideLayout Include="@(_GetResolvedSDKReferencesOutput)" />
      <!-- Exclude any PRIOutputs that come from other projects so we avoid duplicates -->
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsFromOtherProjects)" Exclude="@(PriOutputs)"/>
    </ItemGroup>

    <ItemGroup>
      <PathsToExcludeFromLayoutOutputGroup Include="@(_PackagingOutputsOutsideLayout->'%(TargetPath)')" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(AppxManifestTargetPath)" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(DeploymentRecipeTargetPath)" />
    </ItemGroup>

    <ItemGroup>
      <DirsToExcludeFromLayoutOutputGroup Include="$(WinMetadataDir)" />
      <DirsToExcludeFromLayoutOutputGroup Include="$(EntryPointDir)" />
    </ItemGroup>

    <ReunionExpandPayloadDirectories Condition="'$(IncludeLayoutFilesInPackage)' == 'true'" Inputs="$(LayoutDir)" TargetDirsToExclude="@(DirsToExcludeFromLayoutOutputGroup)" TargetFilesToExclude="@(PathsToExcludeFromLayoutOutputGroup)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsFromLayout" />
    </ReunionExpandPayloadDirectories>

    <ItemGroup>
      <PackagingOutputs Include="@(_PackagingOutputsFromLayout)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>LayoutOutputGroup</OutputGroup>
      </PackagingOutputs>
      <PackagingOutputs Include="@(_PackagingOutputsOutsideLayout)" />
      <PackagingOutputs Include="@(_ProjectArchitectureItem)" />
    </ItemGroup>

  </Target>

  <Target Name="_ComputeAppxPackagePayload">
    <ItemGroup>
      <!-- If a nuget package contains a .pri file, the .NET SDK puts the .pri file in the deps.json - so we can't filter it out here
        <_UnfilteredAppxPackagePayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND '%(OutputGroup)' != 'GetResolvedSDKReferences' AND '%(OutputGroup)' != '_GetProjectArchitecture' AND '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      -->
      <!--
        We ignore the following files in the payload:
        OutputGroup.GetResolvedSDKReferences - These items are framework packages, and thus shouldn't be in the app package.
          They will instead be referenced by the manifest.
        OutputGroup._GetProjectArchitecture - This item is not meaningful and is something like "x64"
        OutputGroup.EmbedOutputGroupForPackaging - These files will be embedded in a PRI file.
      -->
      <_UnfilteredAppxPackagePayload Include="@(PackagingOutputs)"
                                     Condition="'%(PackagingOutputs.OutputGroup)' != 'GetResolvedSDKReferences' AND
                                                '%(PackagingOutputs.OutputGroup)' != '_GetProjectArchitecture'AND
                                                '%(PackagingOutputs.OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxPackagePayload Include="@(ProjectPriFile)" />
    </ItemGroup>

    <!-- The above comments apply to the ItemGroup below -->
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <!--<_UnfilteredAppxUploadPackagePayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND '%(OutputGroup)' != 'GetResolvedSDKReferences' AND '%(OutputGroup)' != '_GetProjectArchitecture' AND '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/> -->
      <_UnfilteredAppxUploadPackagePayload Include="@(PackagingOutputs)"
                                           Condition="'%(PackagingOutputs.OutputGroup)' != 'GetResolvedSDKReferences' AND
                                                      '%(PackagingOutputs.OutputGroup)' != '_GetProjectArchitecture'AND
                                                      '%(PackagingOutputs.OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxUploadPackagePayload Include="@(ProjectPriUploadFile)" />
    </ItemGroup>

    <!-- Users can manually populate the AppxPackagePayload. In the .NetNative case, this is handled by ILC. Otherwise, we need to retain those files -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true'">

      <!-- If the user added a payload with a rooted path, we can safely use that -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'true'" Include="@(AppxPackagePayload->'%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(AppxPackagePayload..TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- If the user added a payload with a relative path, we make the assumption that it's relative to the project root and build out the full path -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'false'" Include="@(AppxPackagePayload->'$(MSBuildProjectDirectory)\%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(AppxPackagePayload..TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- Reset the AppxPackagePayload to avoid duplicate entries later -->
      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
    </ItemGroup>

    <ReunionRemovePayloadDuplicates Inputs="@(_UnfilteredAppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="AppxPackagePayload" />
    </ReunionRemovePayloadDuplicates>

    <ReunionRemovePayloadDuplicates Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="@(_UnfilteredAppxUploadPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="DeDupedAppxUploadPackagePayload" />
    </ReunionRemovePayloadDuplicates>

    <!-- If packaging outputs contain a file named AppxManifest.xml, this is an override manifest and it is handled elsewhere.
        If packaging outputs contain the store association file, we need to remove it. Furthermore,
        we need to remove the SourceAppxContentGroupMap file, or if producing an Appx Bundle, the AppxContentGroupMap as well.
        Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in. -->
    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == '$(AppxManifestFileName)'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == 'Package.StoreAssociation.xml'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == 'SourceAppxContentGroupMap.xml'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND '$(ProduceAppxBundle)' == 'true' AND '%(AppxPackagePayload.TargetPath)' == 'AppxContentGroupMap.xml'" />

      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <DeDupedAppxUploadPackagePayload Remove="@(DeDupedAppxUploadPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <!-- If we are NOT going through the .Net Native toolchain, this generated payload becomes the payload we'll package for upload -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackagePayload Include="@(DeDupedAppxUploadPackagePayload)" />
    </ItemGroup>

    <!-- If the Upload packaging outputs contain the store association file, the SourceAppxContentGroupMap file,
         or if producing an Appx Bundle, the AppxContentGroupMap, we need to remove it
         Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in. -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == 'Package.StoreAssociation.xml'" />
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == 'SourceAppxContentGroupMap.xml'" />
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND '$(ProduceAppxBundle)' == 'true' AND '%(AppxPackagePayload.TargetPath)' == 'AppxContentGroupMap.xml'" />

      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxUploadPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>

    <ItemGroup>
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture' AND '%(PackagingOutputs.MSBuildSourceProjectFile)' != ''" />
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture' AND '%(PackagingOutputs.MSBuildSourceProjectFile)' == ''">
        <MSBuildSourceProjectFile>$(MSBuildProjectFullPath)</MSBuildSourceProjectFile>
      </_ProjectArchitectureFromPayload>
    </ItemGroup>

    <ReunionGenerateProjectArchitecturesFile ProjectArchitectures="@(_ProjectArchitectureFromPayload)" ProjectArchitecturesFilePath="$(_ProjectArchitecturesFilePath)" VsTelemetrySession="$(VsTelemetrySession)"/>

    <ItemGroup>
      <FileWrites Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxPackageRecipe"/>

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_CalculateInputsForGenerateAppxPackageRecipe">
    <ItemGroup>
      <_GenerateAppxPackageRecipeInput Include="@(FinalAppxManifest)" />
      <_GenerateAppxPackageRecipeInput Include="@(AppxPackagePayload)" />
      <_GenerateAppxPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
      <_GenerateAppxPackageRecipeInput Include="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />
    </ItemGroup>

    <ItemGroup>
      <PDBPayload Include="@(AppxPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>

  <Target Name="_GenerateAppxPackageRecipe" DependsOnTargets="$(_GenerateAppxPackageRecipeDependsOn)"/>

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_GenerateAppxPackageRecipeFile" Inputs="$(MSBuildAllProjects);@(_GenerateAppxPackageRecipeInput)" Outputs="$(AppxPackageRecipe)">
    <!-- Set the RecipeContentGroupMap if the AppxContentGroupMap file is not already included in the payload. This happens when ProduceAppxBundle is not true. -->
    <PropertyGroup>
      <RecipeContentGroupMap Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxContentGroupMapFullPath)</RecipeContentGroupMap>
    </PropertyGroup>

    <ReunionGenerateAppxPackageRecipe
        AppxContentGroupMap="$(RecipeContentGroupMap)"
        AppxManifestXml="%(FinalAppxManifest.FullPath)"
        AppxBundleManifestXml="$(FinalAppxBundleManifestName)"
        SourceAppxManifest="@(SourceAppxManifest)"
        SolutionConfiguration="$(Configuration)|$(Platform)"
        PayloadFiles="@(AppxPackagePayload)"
        FrameworkSdkPackages="@(FrameworkSdkPackage)"
        RecipeFile="$(AppxPackageRecipe)"
        SystemBinaries="@(AppxSystemBinary)"
        ReservedFileNames="@(AppxReservedFileName)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestFileNameQueries="@(AppxManifestFileNameQuery)"
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        AdditionalReRegisterAppIfChangedTargetPaths="@(AdditionalReRegisterAppIfChangedTargetPaths)"
        PackageArchitecture="$(PackageArchitecture)"
        ProjectDir="$(ProjectDir)"
        IntermediateOutputPath="$(IntermediateOutputPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformVersion)"
        PlatformVersionDescriptions="@(PlatformVersionDescription)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)"
        RemoteDeploymentType="$(RemoteDeploymentType)"
        PackageRegistrationPath="$(PackageRegistrationPath)"
        RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)"
        WindowsSdkPath="$(WindowsSdkPath)"
        LayoutDir="$(LayoutDir)"
        OptionalProjectRecipeFiles="@(BundleMappingRecipes)"
        DeployOptionalPackages="$(DeployOptionalPackages)"
        VsTelemetrySession="$(VsTelemetrySession)"
        />

    <ItemGroup>
      <AllGeneratedRecipes Include="$(AppxPackageRecipe)" />
    </ItemGroup>

    <Message Importance="low" Text="Manifest: %(FinalAppxManifest.Identity)" />
    <Message Importance="low" Text="Payload: %(AppxPackagePayload.TargetPath) from %(AppxPackagePayload.FullPath)" />
    <Message Importance="low" Text="SDK reference: %(RecursiveResolvedSDKReference.TargetPath) from %(RecursiveResolvedSDKReference.FullPath)" />
    <Message Importance="low" Text="$(MSBuildProjectName) -> $(AppxPackageRecipe)" />
  </Target>

  <Target Name="_GetPackageArchitecture">
    <ReunionGetPackageArchitecture Platform="$(Platform)" ProjectArchitecture="@(ProjectArchitecture)" RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </ReunionGetPackageArchitecture>
  </Target>

  <Target Name="_GetPackageProperties" DependsOnTargets="$(_GetPackagePropertiesDependsOn)" />

  <Target Name="_GetRecursiveProjectArchitecture">
    <ItemGroup>
      <_RecursiveProjectArchitecture Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'" />
      <_RecursiveProjectArchitecture Remove="@(_RecursiveProjectArchitecture)" Condition="'%(PackagingOutputs.ProjectName)' == '$(ProjectName)'" />
    </ItemGroup>
  </Target>

  <Target Name="_GetPackageArchitecture">
    <ReunionGetPackageArchitecture Platform="$(Platform)" ProjectArchitecture="@(ProjectArchitecture)" RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </ReunionGetPackageArchitecture>
  </Target>

  <Target Name="_CalculateAppxBundleProperties" Condition="'$(AppxBundle)' != 'Never'">

    <PropertyGroup>
      <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''">$(PackageArchitecture)</AppxBundlePlatforms>
    </PropertyGroup>

    <ReunionGetAppxBundlePlatforms Input="$(AppxBundlePlatforms)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Platforms" ItemName="AppxBundlePlatform" />
      <Output TaskParameter="Last" PropertyName="AppxBundleLastPlatform" />
    </ReunionGetAppxBundlePlatforms>

    <ItemGroup>
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' == 'neutral'" Include="@(AppxBundlePlatform -> 'AnyCPU')" />
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' != 'neutral'" Include="@(AppxBundlePlatform)" />
    </ItemGroup>

    <PropertyGroup>
      <_AppxBundlePlatformsForNamingIntermediate>@(AppxBundlePlatformWithAnyCPU)</_AppxBundlePlatformsForNamingIntermediate>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformsForNaming>$(_AppxBundlePlatformsForNamingIntermediate.Replace(';','_'))</AppxBundlePlatformsForNaming>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleProducingPlatform>
      <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleResourcePacksProducingPlatform>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformSpecificArtifactsListPath>$(PlatformSpecificBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificArtifactsListPath>
    </PropertyGroup>

    <PropertyGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxBundlePlatformSpecificUploadArtifactsListPath>$(PlatformSpecificUploadBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificUploadArtifactsListPath>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxBundle)'==''">
      <AppxBundle Condition="$(AppxBundlePlatforms.Contains('|'))">Always</AppxBundle>
      <AppxBundle Condition="'$(AppxBundle)'==''">Auto</AppxBundle>
    </PropertyGroup>
  </Target>

  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.Build.Msix.Pri.targets"/>

</Project>